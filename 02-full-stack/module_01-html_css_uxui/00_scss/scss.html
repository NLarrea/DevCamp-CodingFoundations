<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="introducci%C3%B3n-a-scss">Introducción a SCSS</h1>
<div id="indice"></div>
<ul>
<li><a href="#%C2%BFqu%C3%A9-es-scss">¿Qué es SCSS?</a></li>
<li><a href="#diferencia-entre-sass-y-scss">Diferencia entre SASS y SCSS</a></li>
<li><a href="#variables-y-estructura-scss">Variables y estructura SCSS</a>
<ul>
<li><a href="#default-values">Valores por defecto</a></li>
<li><a href="#anidaci%C3%B3n-en-scss">Anidación</a></li>
</ul>
</li>
<li><a href="#mixins">Mixins</a>
<ul>
<li><a href="#mixins-con-argumentos">Mixins con argumentos</a></li>
<li><a href="#mixins-con-condicionales">Mixins con condicionales</a></li>
<li><a href="#content">Content</a></li>
</ul>
</li>
<li><a href="#crear-clases-din%C3%A1micas">Crear clases dinámicas</a>
<ul>
<li><a href="#listas">Listas</a></li>
<li><a href="#directiva-each">Directiva each</a></li>
<li><a href="#interpolaci%C3%B3n-de-strings">Interpolación de Strings</a></li>
</ul>
</li>
<li><a href="#import">Import</a></li>
</ul>
<p><br><hr></p>
<hr><br>
<h2 id="%C2%BFqu%C3%A9-es-scss">¿Qué es SCSS?</h2>
<p><sub><a href="#indice">&lt;&lt; Volver al índice</a> | <a href="#diferencia-entre-sass-y-scss">SASS vs SCSS &gt;&gt;</a></sub></p>
<p>SCSS son las siglas de Sassy Cascading Style Sheets. Fue creado hace aproximadamente 10 años por Hampton Catlin.</p>
<p>¿Dónde se puede usar SCSS? A día de hoy, puede usarse en prácticamente cualquier tipo de framework. No está atado a ningún tipo concreto de elemento.</p>
<p>¿Por qué usar SCSS? SCSS permite agilizar todo el proceso de implementación de un diseño. Escribir únicamente con CSS puro está bien, pero lo que SCSS permite, es agilizar el proceso de implementación de un diseño, ya que permite escribir código CSS de una forma más sencilla y rápida, eliminando cualquier tipo de proceso repetitivo.</p>
<p>Técnicamente, SCSS es un preprocesador, lo que significa que es un tipo de lenguaje que el navegador no entiende. Cuando el preprocesador se ejecuta, lo que hace es convertir todo el código SCSS que escribiste en código CSS, de forma que el navegador sí que lo entienda, construyendo tus propios archivos CSS para ti.</p>
<p><br><hr></p>
<hr><br>
<h2 id="diferencia-entre-sass-y-scss">Diferencia entre SASS y SCSS</h2>
<p><sub><a href="#%C2%BFqu%C3%A9-es-scss">&lt;&lt; SCSS</a> | <a href="#indice">Volver al índice</a> | <a href="#variables-y-estructura-scss">Variables &gt;&gt;</a></sub></p>
<p><strong>SASS</strong> es la versión original de SCSS. No se parece en nada al CSS y se preocupa por cosas como la indentación. No tiene llaves, tiene signos de más y signos de igual por todas partes, etc.</p>
<p><strong>SCSS</strong> se parece exactamente al CSS, usa llaves y puntos y comas. Es mucho más familiar.</p>
<p>Si quieres escribir código CSS puro, un archivo SCSS lo procesará, mientras que la versión original de SASS lanzaría un error.</p>
<p><br><hr></p>
<hr><br>
<h2 id="variables-y-estructura-scss">Variables y estructura SCSS</h2>
<p><sub><a href="#diferencia-entre-sass-y-scss">&lt;&lt; SASS vs SCSS</a> | <a href="#indice">Volver al índice</a> | <a href="#valores-por-defecto">Valores por defecto &gt;&gt;</a></sub></p>
<p>Las variables son una especie de contenedor donde se puede almacenar el valor de una propiedad. En este caso, vamos a crear dos variables de colores para aplicarlas a lo largo el programa:</p>
<pre class="hljs"><code><div><span class="hljs-variable">$off-white</span>: <span class="hljs-number">#f6f6f6</span>;
<span class="hljs-variable">$master-site-color</span>: darkred;

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$off-white</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;
}

<span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">font-family</span>: Verdana, Geneva, Tahoma, sans-serif;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8rem</span>;
}

<span class="hljs-selector-class">.page-wrapper</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">21px</span>;

    <span class="hljs-selector-class">.featured</span> {
        <span class="hljs-attribute">color</span>: <span class="hljs-variable">$master-site-color</span>;
    }

    <span class="hljs-selector-class">.page-content</span>{
        <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$master-site-color</span>;
        <span class="hljs-attribute">padding</span>: <span class="hljs-number">42px</span>;
        <span class="hljs-attribute">color</span>: <span class="hljs-variable">$off-white</span>;

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Courier New'</span>, Courier, monospace;
        }
    }
}
</div></code></pre>
<br>
<p>Este sería el resultado:</p>
<p><img src="./images/01-variables/00-variables.png" alt="00-variables.png"></p>
<br>
<p>Como se puede ver, las variables son muy útiles para no tener que repetir el mismo valor en diferentes partes del código. Además, si se quiere cambiar el valor de una variable, se puede hacer de forma muy sencilla, sin tener que cambiar el valor en cada parte del código donde se haya usado.</p>
<p>Por ejemplo, si modificamos la variable <code>$master-site-color</code> a un color verde, el programa se vería así:</p>
<p><img src="./images/01-variables/01-variables-color-changed.png" alt="01.variables-color-changed.png"></p>
<p><br><hr><br></p>
<h3 id="valores-por-defecto">Valores por defecto</h3>
<p><sub><a href="#variables-y-estructura-scss">&lt;&lt; Variables</a> | <a href="#indice">Volver al índice</a> | <a href="#anidaci%C3%B3n-en-scss">Anidación &gt;&gt;</a></sub></p>
<p>Aunque aún no se ha hablado de ellos, en este y el siguiente apartado se van a usar los <em><strong>mixins</strong></em>. Los mixins son una especie de funciones que se pueden usar en SCSS de las cuales hablaremos más adelante. No es importante saber qué son o cómo funcionan por ahora.</p>
<p>Podemos crear valores por defecto de la siguiente manera:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> heading-feature-styling {
    <span class="hljs-variable">$feature-color</span>: DarkRed !default;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$feature-color</span>;
}

<span class="hljs-keyword">@mixin</span> section-feature-styling {
    <span class="hljs-variable">$feature-color</span>: DarkRed !default;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$feature-color</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">42px</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$off-white</span>;
}
</div></code></pre>
<br>
<p>Así es como se vería:</p>
<p><img src="./images/01-variables/00-variables.png" alt="00-variables.png"></p>
<br>
<p>Si la variable <code>$feature-color</code> no se define (como si fuera una variable más), se usará el valor especificado antes de <code>!default</code>. Pero si se crea una variable con ese nombre, se usará ese valor de la variable:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* VARIABLES */</span>
<span class="hljs-variable">$feature-color</span>: darkgreen;

<span class="hljs-comment">/* MIXINS */</span>
<span class="hljs-keyword">@mixin</span> heading-feature-styling {
    <span class="hljs-variable">$feature-color</span>: DarkRed !default;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$feature-color</span>;
}

<span class="hljs-keyword">@mixin</span> section-feature-styling {
    <span class="hljs-variable">$feature-color</span>: DarkRed !default;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$feature-color</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">42px</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$off-white</span>;
}
</div></code></pre>
<br>
<p>En este caso, así es como quedaría:</p>
<p><img src="./images/01-variables/01-variables-color-changed.png" alt="01-variables-color-changed.png"></p>
<p><br><hr><br></p>
<h3 id="anidaci%C3%B3n-en-scss">Anidación en SCSS</h3>
<p><sub><a href="#variables-y-estructura-scss">&lt;&lt; Variables</a> | <a href="#indice">Volver al índice</a> | <a href="#mixins">Mixins &gt;&gt;</a></sub></p>
<p>Para anidar elementos en CSS se podía utilizar <code>&lt;</code> para indicar que un elemento se encontraba dentro de otro.</p>
<p>Con SCSS se vuelve todo mucho más sencillo. Ya se ha visto en los ejemplos anteriores la sintáxis para anidar elementos, o indicar que uno se encuentra dentro del otro. Para ello, basta con escribir y dar estilo al elemento dentro de su contenedor:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.page-wrapper</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">21px</span>;

    <span class="hljs-selector-class">.featured</span> {
        <span class="hljs-keyword">@include</span> heading-feature-styling;
    }

    <span class="hljs-selector-class">.page-content</span>{
        <span class="hljs-keyword">@include</span> section-feature-styling;

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Courier New'</span>, Courier, monospace;
        }
    }
}
</div></code></pre>
<br>
<p>En este ejemplo, podemos entender que el elemento <code>.container</code> se encuentra dentro del elemento <code>.page-content</code>, que a su vez se encuentra dentro del elemento <code>.page-wrapper</code>.</p>
<p><code>.page-content</code> está dentro de <code>.page-wrapper</code>, pero <code>.featured</code> también, lo que significa que estos dos elementos se encuentran dentro de un mismo contenedor: <code>.page-wrapper</code>.</p>
<br>
<ul>
<li><strong>Anidación con pseudoclase</strong></li>
</ul>
<p>De nuevo, en CSS la forma de dar estilo a un elemento con una pseudoclase era la de volver a definir el elemento en otro bloque de código, pero con la pseudoclase añadida.</p>
<p>Ahora, con SCSS, se puede anidar el elemento con la pseudoclase, de la siguiente manera:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.subheading</span> <span class="hljs-selector-tag">a</span> {
    <span class="hljs-attribute">color</span>: cornflowerblue;
    <span class="hljs-attribute">text-decoration</span>: none;

    &amp;<span class="hljs-selector-pseudo">:hover</span> {
        <span class="hljs-attribute">color</span>: darkolivegreen;
        <span class="hljs-attribute">text-decoration</span>: underline;
    }
}
</div></code></pre>
<br>
<p>El equivalente CSS sería el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.subheading</span> <span class="hljs-selector-tag">a</span> {
    <span class="hljs-attribute">color</span>: cornflowerblue;
    <span class="hljs-attribute">text-decoration</span>: none;
}

<span class="hljs-selector-class">.subheading</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: darkolivegreen;
    <span class="hljs-attribute">text-decoration</span>: underline;
}
</div></code></pre>
<br>
<p>En este caso, refetir la referencia al elemento dos veces no es muy tedioso porque no ha habido que especificar sus contenedores, pero sigue siendo una forma de repetirse de forma innecesaria. Es mucho más rápido aplicar SCSS.</p>
<p><br><hr></p>
<hr><br>
<h2 id="mixins">Mixins</h2>
<p><sub><a href="#variables-y-estructura-scss">&lt;&lt; Variables</a> | <a href="#indice">Volver al índice</a> | <a href="#mixins-con-argumentos">Con argumentos &gt;&gt;</a></sub></p>
<p>Son una especie de funciones que pueden ser &quot;llamadas&quot;. Son muy útiles para aplicar los mismos estilos en diferentes elementos, o simplemente para ayudar a organizar los estilos. Para definir un <em>&quot;mixin&quot;</em>, se usa la sintaxis <code>@mixin</code>.</p>
<p>En este ejemplo, vamos a crear los siguientes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> heading-feature-styling {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$master-site-color</span>;
}

<span class="hljs-keyword">@mixin</span> section-feature-styling {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$master-site-color</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">42px</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$off-white</span>;
}
</div></code></pre>
<br>
<p>Esto haría que el programa se viera modificado, <em><strong>¿por qué? ¿Qué es lo que falta?</strong></em></p>
<p>Ahora, nos queda indicar qué elementos deben <em>&quot;coger&quot;</em> las propiedades definidas en dichos mixins. Para ello, se usa la palabra reservada <code>@include</code>:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.page-wrapper</span> {
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">21px</span>;

    <span class="hljs-selector-class">.featured</span> {
        <span class="hljs-keyword">@include</span> heading-feature-styling;
    }

    <span class="hljs-selector-class">.page-content</span>{
        <span class="hljs-keyword">@include</span> section-feature-styling;

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'Courier New'</span>, Courier, monospace;
        }
    }
}
</div></code></pre>
<br>
<p>Como se puede observar, el resultado no se vería modificado:</p>
<p><img src="./images/01-variables/01-variables-color-changed.png" alt="01-variables-color-changed.png"></p>
<p><br><hr><br></p>
<h3 id="mixins-con-argumentos">Mixins con argumentos</h3>
<p><sub><a href="#mixins">&lt;&lt; Mixins</a> | <a href="#indice">Volver al índice</a> | <a href="#mixins-con-condicionales">Con condiciones &gt;&gt;</a></sub></p>
<p>En el ejemplo de arriba hemos usado <em><strong>mixins</strong></em> sin argumentos, lo que significa que son <em>estáticos</em>, es decir, iguales para todos. Pero, ¿qué pasa si queremos que haya elementos compartiendo estilo con pequeñas diferencias? Para ello, se pueden usar argumentos en los <em><strong>mixins</strong></em>, como si se tratara de funciones:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> featured(<span class="hljs-variable">$link-color</span>: black) {
    <span class="hljs-attribute">color</span>: Tomato;
    
    <span class="hljs-selector-class">.subheading</span> <span class="hljs-selector-tag">a</span> {
        <span class="hljs-attribute">color</span>: <span class="hljs-variable">$link-color</span>;
        <span class="hljs-attribute">text-decoration</span>: none;

        &amp;<span class="hljs-selector-pseudo">:hover</span> {
            <span class="hljs-attribute">color</span>: <span class="hljs-variable">$link-color</span>;
            <span class="hljs-attribute">text-decoration</span>: underline;
        }
    }
}
</div></code></pre>
<br>
<p>El <em><strong>mixin</strong></em> creado tiene una variable, <code>$link-color</code>, que por defecto tiene el valor <code>black</code>. Si no se le pasa ningún argumento, se usará el valor por defecto. Pero si se le pasa un argumento, se usará ese valor.</p>
<p>No es necesario indicar que <code>$link-color</code> tenga un valor concreto al declarar el <em><strong>mixin</strong></em>, podría no ponerse ninguno y enconces habría que especificar siempre un color al llamar al <em><strong>mixin</strong></em>.</p>
<br>
<p>Como en este caso hemos especificado un valor por defecto, podemos realizar lo siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.page-wrapper</span> {
    <span class="hljs-comment">/* some code */</span>

    <span class="hljs-selector-class">.featured</span> {
        <span class="hljs-keyword">@include</span> featured; <span class="hljs-comment">// no se pasa argumento -&gt; usa el valor por defecto</span>
    }

    <span class="hljs-selector-class">.page-content</span>{
        <span class="hljs-comment">/* some code */</span>

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-comment">/* some code */</span>

            <span class="hljs-selector-class">.sidebar</span> {
                <span class="hljs-comment">/* some code */</span>
                <span class="hljs-keyword">@include</span> featured(mintcream); <span class="hljs-comment">// usa el valor "mintcream"</span>
            }
        }
    }
}
</div></code></pre>
<br>
<p>El resultado sería el siguiente, donde se puede ver que cada link debajo del &quot;About us&quot; tiene un color distinto:</p>
<p><img src="./images/02-mixins/00-mixin-with-arguments.png" alt="00-mixin-with-arguments.png"></p>
<p><br><hr><br></p>
<h3 id="mixins-con-condicionales">Mixins con condicionales</h3>
<p><sub><a href="#mixins">&lt;&lt; Mixins</a> | <a href="#indice">Volver al índice</a> | <a href="#content">Content &gt;&gt;</a></sub></p>
<p>Se pueden crear sentencias condicionales dentro de los <em><strong>mixins</strong></em>. Las sentencias condicionales (<code>if</code>, <code>else if</code> y <code>else</code>) pueden servir para definir distintos tipos de escenarios. Para definirlas, se debe escribir el caracter <code>@</code> antes de cada una de ellas.</p>
<p>He aquí un ejemplo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> featured(<span class="hljs-variable">$bg-color</span>: <span class="hljs-string">'dark'</span>) {
    <span class="hljs-keyword">@if</span> <span class="hljs-variable">$bg-color</span> == <span class="hljs-string">'light'</span> {
        <span class="hljs-attribute">color</span>: Tomato;
    } <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$bg-color</span> == <span class="hljs-string">'dark'</span> {
        <span class="hljs-attribute">color</span>: blue;
    } <span class="hljs-keyword">@else</span> {
        <span class="hljs-attribute">color</span>: red;
    }
    
    <span class="hljs-comment">/* some other code */</span>
}
</div></code></pre>
<br>
<p>Al igual que en el apartado anterior vimos cómo pasar parámetros a un <em><strong>mixin</strong></em>, en este caso las llamadas al <em><strong>mixin</strong></em> funcionan de la misma forma:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.page-wrapper</span> {
    <span class="hljs-comment">/* some code */</span>

    <span class="hljs-selector-class">.featured</span> {
        <span class="hljs-keyword">@include</span> featured(<span class="hljs-string">'light'</span>);
    }

    <span class="hljs-selector-class">.page-content</span>{
        <span class="hljs-comment">/* some code */</span>

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-comment">/* some code */</span>

            <span class="hljs-selector-class">.sidebar</span> {
                <span class="hljs-comment">/* some code */</span>

                <span class="hljs-keyword">@include</span> featured(<span class="hljs-string">'grey'</span>);
            }
        }
    }
}
</div></code></pre>
<br>
<p>Lo que va a ocurrir es que el <code>@include</code> de la clase <code>.featured</code> entrará en el primer <code>@if</code> tomando el color <em>tomato</em>. El <code>@include</code> de la clase <code>.sidebar</code> entrará en la tercera opción (<code>@else</code>) tomando el color <em>red</em> porque no encaja con ninguna de las opciones anteriores.</p>
<p>Si no se le hubiera indicado ningún valor, hubiera entrado en la sentencia <code>@else if</code> porque tendría ese valor por defecto.</p>
<p>Este es el resultado:</p>
<p><img src="./images/02-mixins/01-mixin-with-conditional.png" alt="01-mixin-with-conditional.png"></p>
<p><br><hr></p>
<hr><br>
<h2 id="content">Content</h2>
<p><sub><a href="#mixins">&lt;&lt; Mixins</a> | <a href="#indice">Volver al índice</a> | <a href="#crear-clases-din%C3%A1micas">Clases dinámicas &gt;&gt;</a></sub></p>
<p>El <code>@content</code> es una palabra clave que permite realizar lo mismo que lo visto en el apartado de <a href="#mixins-con-argumentos">mixins con argumentos</a>, pero de una forma más sencilla e intuitiva.</p>
<br>
<p>Vamos a suponer que tenemos el siguiente código HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>
        There was an error processing your request.
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"success"</span>&gt;</span>
        Your request was processed successfully.
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</div></code></pre>
<br>
<p>Queremos que cada div tenga unos colores diferentes, pero los demás estilos sean los mismos. Para ello, vamos a crear un <em><strong>mixin</strong></em> que se aplique a ambos elementos:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> notification(<span class="hljs-variable">$background-color</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$border</span>){
    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">35px</span>;
    <span class="hljs-attribute">text-align</span>: center;
    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;
    <span class="hljs-attribute">font-family</span>: Verdana, Geneva, Tahoma, sans-serif;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$background-color</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$color</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-variable">$border</span>;
}
</div></code></pre>
<br>
<p>Ahora, para llamar al <em><strong>mixin</strong></em> y modificar los valores que queramos, se puede hacer de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.error</span> {
    <span class="hljs-keyword">@include</span> notification(<span class="hljs-variable">$background-color</span>: DarkRed, <span class="hljs-variable">$color</span>: white, <span class="hljs-variable">$border</span>: <span class="hljs-number">1px</span> solid LightSlateGray)
}

.success {
    <span class="hljs-keyword">@include</span> notification(<span class="hljs-variable">$background-color</span>: MediumSeaGreen, <span class="hljs-variable">$color</span>: MintCream, <span class="hljs-variable">$border</span>: <span class="hljs-number">1px</span> solid LightSalmon)
}
</div></code></pre>
<br>
<p>Esto sería lo primero que se nos hubiera ocurrido. Sin embargo, a la hora de llamar al <em><strong>mixin</strong></em>, no se ve de forma tan clara qué valores están siendo modificados.</p>
<p>Para ayudar a ver esto de forma más clara, se puede utilizar el <code>@content</code>, manteniendo dentro del <em><strong>mixin</strong></em> el código que se quiere repetir, y fuera del <em><strong>mixin</strong></em>, el código que se quiere modificar.:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@mixin</span> notification{
    <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">35px</span>;
    <span class="hljs-attribute">text-align</span>: center;
    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;
    <span class="hljs-attribute">font-family</span>: Verdana, Geneva, Tahoma, sans-serif;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-keyword">@content</span>;
}
</div></code></pre>
<br>
<p>Ahora, para llamar al <em><strong>mixin</strong></em> y modificar los valores que queramos, se puede hacer de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.error</span> {
    <span class="hljs-keyword">@include</span> notification{
        <span class="hljs-attribute">background-color</span>: darkred;
        <span class="hljs-attribute">color</span>: white;
        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid lightslategray;
    }

}

<span class="hljs-selector-class">.success</span> {
    <span class="hljs-keyword">@include</span> notification{
        <span class="hljs-attribute">background-color</span>: mediumseagreen;
        <span class="hljs-attribute">color</span>: mintcream;
        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid lightsalmon;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">75%</span>; <span class="hljs-comment">// sobreescribe el valor del mixin</span>
    }
}
</div></code></pre>
<br>
<p>El resultado es el siguiente:</p>
<p><img src="./images/02-mixins/02-content.png" alt="02-content.png"></p>
<p><br><hr></p>
<hr><br>
<h2 id="crear-clases-din%C3%A1micas">Crear clases dinámicas</h2>
<p><sub><a href="#content">&lt;&lt; Content</a> | <a href="#indice">Volver al índice</a> | <a href="#listas">Listas &gt;&gt;</a></sub></p>
<p>En este apartado se va a hablar de cómo crear clases dinámicas utilizando un ejemplo muy sencillo:</p>
<p>Imagina que se tiene este código HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"car-maserati"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"car-tesla"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"car-porsche"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</div></code></pre>
<p>Y se desea utilizar 3 imágenes diferentes para cada uno de los <code>div</code>. El estilo de cada elemento va a ser el mismo, siendo la imagen de fondo la única diferencia.</p>
<p><em><strong>¿Qué se puede hacer?</strong></em></p>
<p>Vamos a aprender a crear clases dinámicas para escribir únicamente un bloque de código que se aplique a los tres elementos gracias a modificar su clase.</p>
<p>Para ello, vamos a seguir los siguientes pasos:</p>
<ol>
<li>Crear una lisa con el nombre (sin extensión) de cada imagen que se va a utilizar.</li>
<li>Utilizar la directiva <code>each</code> para recorrer la lista y crear una clase dinámica para cada elemento.</li>
</ol>
<p>Para crear las clases dinámicas, se va a utilizar la interpolación de strings. Esto permite crear una cadena de texto que se modifique utilizando variables.</p>
<p><br><hr><br></p>
<h3 id="listas">Listas</h3>
<p><sub><a href="#crear-clases-din%C3%A1micas">&lt;&lt; Clases dinámicas</a> | <a href="#indice">Volver al índice</a> | <a href="#directiva-each">Each &gt;&gt;</a></sub></p>
<p>Para crear una lista en SCSS, se realiza lo siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-variable">$cars</span>: <span class="hljs-string">'maserati'</span>, <span class="hljs-string">'tesla'</span>, <span class="hljs-string">'porsche'</span>;
</div></code></pre>
<br>
<p>Como se puede ver, es una variable, cuya sintaxis es la misma que la de cualquier otra variable. La diferencia es que en lugar de contener un valor, contiene una lista de valores.</p>
<p><br><hr><br></p>
<h3 id="directiva-each">Directiva each</h3>
<p><sub><a href="#crear-clases-din%C3%A1micas">&lt;&lt; Clases dinámicas</a> | <a href="#indice">Volver al índice</a> | <a href="#interpolaci%C3%B3n-de-strings">Interpolar strings &gt;&gt;</a></sub></p>
<p>La directiva <code>each</code> permite recorrer una lista y ejecutar un bloque de código para cada uno de los elementos de la lista.</p>
<p>La sintaxis es la siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@each</span> <span class="hljs-variable">$item</span> in <span class="hljs-variable">$list</span> {
    <span class="hljs-comment">/* some code */</span>
}
</div></code></pre>
<br>
<p>En nuestro ejemplo, vamor a realizar lo siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">@each</span> <span class="hljs-variable">$car-name</span> in <span class="hljs-variable">$cars</span> {
    <span class="hljs-selector-class">.car-</span>#{<span class="hljs-variable">$car-name</span>} {
        <span class="hljs-comment">/* some code */</span>
    }
}
</div></code></pre>
<br>
<p>Con estas líneas de código, se creará una clase dinámica para cada elemento de la lista. El nombre de la clase será el nombre del elemento de la lista precedido por la palabra <code>car-</code>. Lo que daría como resultado las mismas clases que las que hemos visto en el <a href="#crear-clases-din%C3%A1micas">código HTML</a>.</p>
<p>Dentro de este bloque utilizaremos la interpolación de strings para crear las clases dinámicas.</p>
<p><br><hr><br></p>
<h3 id="interpolaci%C3%B3n-de-strings">Interpolación de Strings</h3>
<p><sub><a href="#crear-clases-din%C3%A1micas">&lt;&lt; Clases dinámicas</a> | <a href="#indice">Volver al índice</a> | <a href="#import">Import &gt;&gt;</a></sub></p>
<p>La interpolación de strings permite crear una cadena de texto que se modifique utilizando variables.</p>
<p>Para introducir una variable dentro de un string se utiliza el caracter <code>#</code> seguido del nombre de la variable.</p>
<pre class="hljs"><code><div>#{<span class="hljs-variable">$variable</span>}
</div></code></pre>
<br>
<p>Siguiendo nuestro ejemplo, el código sería el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.car-</span>#{<span class="hljs-variable">$car-name</span>} {
    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">'../../images/module-01/03/#{$car-name}.jpg'</span>);
    <span class="hljs-attribute">background-repeat</span>: no-repeat;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
    <span class="hljs-selector-tag">object</span>-fit: fill;
    <span class="hljs-attribute">float</span>: left;
}
</div></code></pre>
<br>
<p>Con la línea de código mostrada aquí:</p>
<pre class="hljs"><code><div><span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">'../../images/module-01/03/#{$car-name}.jpg'</span>);
</div></code></pre>
<br>
<p>Se está creando una cadena de texto que contiene la ruta de la imagen. El nombre de la imagen se obtiene de la variable <code>$car-name</code> que se está interpolando en el string.</p>
<br>
<p>El código final completo sería el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-variable">$cars</span>: <span class="hljs-string">'maserati'</span>, <span class="hljs-string">'tesla'</span>, <span class="hljs-string">'porsche'</span>;

<span class="hljs-keyword">@each</span> <span class="hljs-variable">$car-name</span> in <span class="hljs-variable">$cars</span> {
    <span class="hljs-selector-class">.car-</span>#{<span class="hljs-variable">$car-name</span>} {
        <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">'../../images/module-01/03/#{$car-name}.jpg'</span>);
        <span class="hljs-attribute">background-repeat</span>: no-repeat;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-selector-tag">object</span>-fit: fill;
        <span class="hljs-attribute">float</span>: left;
    }
}
</div></code></pre>
<br>
<p>El resultado sería el siguiente:</p>
<p><img src="./images/03-dinamizar/00_resultado.png" alt="00_resultado.png"></p>
<p><br><hr></p>
<hr><br>
<h2 id="import">Import</h2>
<p><sub><a href="#crear-clases-din%C3%A1micas">&lt;&lt; Clases dinámicas</a> | <a href="#indice">Volver al índice</a></sub></p>
<p>La directiva <code>@import</code> permite importar archivos SCSS dentro de otros archivos SCSS. Esto permite dividir el código en archivos más pequeños y reutilizar código.</p>
<p>Por lo general, se usa un archivo principal que importa todos los demás archivos.</p>
<p>Esto requiere <strong>tener cuidado con el orden de importación</strong> de los archivos. Como recordatorio, SCSS viene de Sassy Cascading Style Sheets, lo que significa que el orden de importación de los archivos es importante, ya que unos elementos podrían modificar a otros.</p>
<br>
<p>Se ha de saber también, que <code>@import</code> es una directiva un poco antigua. En la actualidad, se recomienda utilizar <code>@use</code> para importar archivos SCSS.</p>
<p><br><hr><br></p>
<p><a href="#indice">Volver al índice</a></p>
<p><br><hr></p>
<hr><br>
<h1 id="contacto">Contacto</h1>
<p>Si tienes alguna duda o sugerencia acerca del contenido de este documento o cualquier otro asunto, no dudes en contactar conmigo:</p>
<div align="center">
&emsp;<a href="https://twitter.com/nloust_"><img width="16" alt="twitter_logo" src="https://user-images.githubusercontent.com/110897750/195668304-54d1fbb3-bea1-4f9d-9ee7-7e494bd79013.png"> @nloust_</a> <!-- twitter: -->
&emsp;<a href="https://www.instagram.com/n.loust/"><img width="16" alt="instagram_logo" src="https://seeklogo.com/images/I/instagram-new-2016-logo-4773FE3F99-seeklogo.com.png"> @n.loust</a> <!-- instagram: -->
&emsp;<a href="https://www.linkedin.com/in/naia-larrea/"><img width="16" alt="linkedin_logo" src="https://user-images.githubusercontent.com/110897750/195669519-30e44b5d-4bef-47d3-9e37-81cff0ee5e55.png"> Naia Larrea</a> <!-- linkedin: -->
</div>
</body>
</html>
